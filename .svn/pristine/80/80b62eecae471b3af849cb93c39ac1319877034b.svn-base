/* Copyright 2001-2004 Roger Dingledine.
 * Copyright (c) 2004-2006, Roger Dingledine, Nick Mathewson.
 * Copyright (c) 2007-2012, The Tor Project, Inc. */
/* See LICENSE for licensing information */

/** String describing which Tor subversion repository version the source was
 * built from.  This string is generated by a bit of shell kludging int
 * src/or/Makefile.am, and is usually right.
 */
const char tor_git_revision[] =
#ifndef _MSC_VER
#include "micro-revision.i"
#endif
  "";

#ifdef LIBRARY
#include <Winsock2.h>
#include <Windows.h>
#include <malloc.h>

#include "../onionroute.h"
#endif

/**
 * \file tor_main.c
 * \brief Stub module containing a main() function. Allows unit
 * test binary to link against main.c.
 **/

int tor_main(int argc, char *argv[]);


#ifdef LIBRARY

void *conn;

void close_callback()
{
	//conn = onionroute_stream_connect("mesra.kl.my.dal.net", 6667);
	//conn = onionroute_stream_connect("www.yahoo.com", 80);
	//conn = onionroute_stream_connect("www.google.org", 80);
	onionroute_stream_connect("www.altavista.com", 80);
}

void open_callback(void *c)
{
	//closesocket(s);
	conn = c;
	onionroute_stream_write(conn, "GET / HTTP/1.0\r\n\r\n", sizeof("GET / HTTP/1.0\r\n\r\n"));
}

void rcv_callback(void *c, int size, char* data)
{
	char* ndata = (char*) _alloca(size + 1);
	memcpy(ndata, data, size);
	ndata[size] = 0;
	printf("----------> Received data: %s", ndata);
}

int launched = 0;

void progresscallback(bootstrap_status_t status, int progress)
{
	if(BOOTSTRAP_STATUS_DONE == status)
	{
		//s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		/* open a connection */
		//onionroute_connect("www.yahoo.com", 80, s);
		if(!launched)
		{
		  //conn = onionroute_stream_connect("mesra.kl.my.dal.net", 6667);
			//conn = onionroute_stream_connect("www.yahoo.com", 80);
			onionroute_stream_connect("www.torproject.org", 80);
		    launched = 1;
		}
	}
}

void logcallback(int severity, log_domain_mask_t domain, const char *funcname, const char *format, va_list ap)
{
	char buf[10024];
	char *end_of_prefix=NULL;
	size_t msg_len = 0;

	 end_of_prefix = onionroute_format_msg(buf, sizeof(buf), domain, severity, funcname, format, ap, &msg_len);

	 OutputDebugStringA(buf); //, msg_len

	 if(LOG_WARN == severity || LOG_NOTICE == severity)
	 printf("%s", buf);
}

#endif


/** We keep main() in a separate file so that our unit tests can use
 * functions from main.c)
 */
int
main(int argc, char *argv[])
{
#ifdef LIBRARY
	int result;

	onionroute_set_bootstrap_callback(&progresscallback);
	onionroute_set_log_callback(&logcallback);
	onionroute_set_stream_close_callback(&close_callback);
	onionroute_set_stream_open_callback(&open_callback);
	onionroute_set_stream_data_received_callback(rcv_callback);

	onionroute_init();
	
	onionroute_setconf("Log=debug\r\n", 0);

	result = do_main_loop();
#else
  return tor_main(argc, argv);
#endif
}

